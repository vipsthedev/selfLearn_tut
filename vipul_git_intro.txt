Training >> 2. GIT Back
Trainer: Samir
Introduction:
In this phase of training, trainee will learn about GIT commands, how to use those commands in regular project
practise.
Topics to study


1.  Make GIT repository

	To create a new Git repository, you have two main options:

	1.1.Initialize a New Git Repository Locally: This is useful if you want to start tracking an existing project with Git.
	1.2.Create a New Repository on GitHub/GitLab/Bitbucket and Clone It: This method involves setting up a repository on a remote Git hosting platform and then cloning it to your local machine.


	1. Initialize a New Git Repository Locally


		Step 1: Open Your Terminal or Command Prompt
			Navigate to the root directory of your project:
				cd path/to/your/project
		Step 2: Initialize a New Git Repository
			Run the following command to initialize a new Git repository in your project directory

			git init

				-This command creates a .git folder in your project's root directory. This folder contains all the necessary metadata and object files that Git needs to track changes in your project.

		Step 3: Add Files to the Repository

			You need to add the files you want to track to the staging area. You can add all files in the directory by running:

				git add .

		Step 4: Commit the Changes

			git commit -m "Initial commit"


2.  Clone GIT repository

	- Create a New Repository on GitHub, GitLab, or Bitbucket and Clone It
	- Once you've created the repository, you'll see a URL (either HTTPS or SSH). Use this URL to clone the repository to your local machine.

	Sign in to your account.

		Look for the option to create a new repository (usually a "New" button or "+" icon).

		Fill out the repository information:

		-Repository name: The name of your repository.
		-Description (optional): A description of the repository.
		-Public/Private: Set the visibility of the repository.
		-Initialize with README: (Optional) Create a README file if desired.
		-Click "Create repository" (the button text might vary depending on the platform).

	1)HTTP

		-Step 1 CLONE URL
			
			https://github.com/vipsthedev/selfLearn_tut.git

		-Step 2: Add Files and Make Your First Commit
	   		cd  vipul_selfLearn_tut

		-Example

		git clone https://github.com/vipsthedev/selfLearn_tut.git
		PS C:\wamp64\www\selfLearn_tut> git status
		
		On branch main
		Your branch is up to date with 'origin/main'.

		nothing to commit, working tree clean



	-------------

	2)SSH
		if you're using SSH:
		
			git clone git@github.com:username/repository.git

	- Additional Setup for a Remote Repository

	  If you initialized a local repository and want to connect it to a remote repository, you can add the remote URL using:

	    git remote add origin https://github.com/username/repository.git

	    Then push your changes to the remote repository:

	    git push -u origin main

3.  Add global configration like name, email

	- To set up global configurations such as your name and email in Git, use the following commands. This sets the information that will be used in all repositories on your machine.


	1. Set Your Name and Email Globally

		Run these commands in your terminal or command prompt to configure your Git username and email globally:

			git config --global user.name "Your Name"
			git config --global user.email "youremail@example.com"

			Replace "Your Name" with your actual name.
			Replace "youremail@example.com" with your email address.
	
	2. Verify Your Global Configuration

		You can verify that your global configuration has been set by running:

		git config --global --list


		output

		PS C:\wamp64\www\selfLearn_tut> git config --global --list
			user.email=vipul@indolytics.com
			user.name=vipul agravat
			user.password=vipul123456789

	3. Local Configuration (Optional)

		If you want to set the name and email for a specific repository (overriding the global configuration), navigate to that repository's directory and run:

			git config user.name "Specific Repo Name"
			git config user.email "specificrepo@example.com"

	4. Additional Global Configuration


		You can set other global configurations as well, such as the default text editor for Git:

			git config --global core.editor "vim"

			On Windows:

				git config --global core.autocrlf true
				

	5. Configuration File Location

		- The global configuration is stored in a file called .gitconfig in your home directory. You can also edit this file directly to change the settings:

		On Windows: C:\Users\YourUsername\.gitconfig
		On macOS/Linux: ~/.gitconfig

4.  Add files to GIT repositry

	- Add your project files to this directory. Then run:
		git add .
		git commit -m "Initial commit"

	- To add files to a Git repository, you'll go through a few simple steps. 
	  These involve moving your changes into the staging area and then committing them to the repository. 
	  Here’s a detailed explanation of each step

	  	1. Navigate to Your Repository
		2. Check Repository Status
			Before adding files, it's often helpful to see the current status of your repository using:
				git status
		3. Add Files to the Staging Area

			The staging area is where you prepare files that you want to commit. Here’s how to add files to it:


			Option 1: Add All Files

					To add all changes (new files, modified files, and deleted files) in the repository to the staging area, use:

						git add .
						/
						git add -A

							git add . adds all changes in the current directory and all nested subdirectories.

							git add -A stages all changes in the repository, including those outside the current directory. This is equivalent to git add --all.


					
					The . tells Git to add all changes in the current directory and its subdirectories.

			Option 2: Add Specific Files

				If you want to add specific files or directories, specify them like this:
					git add filename1 filename2
				Example	

					git add vipul_selfLearn_tut.text vipul.txt

				You can also add an entire directory:

					git add /php/

			Option 3: Add Changes to a Specific Type of Files

				You can use wildcards to add files of a specific type. For example, to add all .html files:

					git add *.html

			Option 4: Add Changes Interactively

				git add -p


					The -p (or --patch) option opens an interactive mode that allows you to review each change before staging it. This is useful if you want to stage only certain parts of a file.
			
			Option 5: Adding Files in an Ignored Directory

					If you need to add files in a directory that is listed in .gitignore but still want to track some specific files, use the -f flag:

					git add -f path/to/ignored/file.txt

					The -f (or --force) option forces Git to add files that would otherwise be ignored.

		4. Check the Staging Area (Optional)
			
				git status

				Files that are ready to be committed will be shown in green under the "Changes to be committed" section.

		5. Commit the Staged Files


			Once the files are staged, you need to commit them to the repository. This creates a snapshot of the changes in the repository’s history. Use the following command:

			git commit -m "Your commit message here"

	 -  6. Push Changes to Remote Repository (If Applicable)

			- If your repository is connected to a remote server (e.g., GitHub, GitLab, Bitbucket), you'll need to push the changes to make them available on the remote server.
			- If you have made changes to the local repository and want to push them to the remote repository:

		 		git push origin main
		 	
		 	- Note: The default branch might be named main or master. Make sure to use the correct branch name based on your repository settings.
		
		7. Understanding the Staging Area and Committing

			Staging Area: When you use git add, you move files to the staging area. This area allows you to group changes before committing them. You can add files to the staging area incrementally to commit only specific changes.
			Committing: A commit in Git creates a snapshot of the changes. You should always write clear and concise commit messages to describe the changes, as this helps in understanding the project's history.


		Additional Notes
			Ignoring Files
			
				If there are files that you do not want to track (like configuration files, environment files, or build artifacts), you can create a .gitignore file in your repository’s root directory. List the files and directories to ignore in this file.
				Example
					# .gitignore
						node_modules/
						.env
						.DS_Store

			Removing Files

				If you need to remove files from the repository, you can use:

				git rm filename
				git commit -m "Removed filename"

				- To stop tracking a file but keep it locally, use:

					git rm --cached filename

5.  Pull GIT repository

	Pulling a Git repository means fetching the latest changes from a remote repository and integrating them into your local repository. This command combines two Git operations: fetching (retrieving new data from the remote) and merging (integrating the new changes into your local branch)

	Pulling Changes from the Remote Repository

		The git pull command is used to fetch changes from the remote repository and merge them into your local branch. Here’s the general syntax:

		git pull <remote> <branch>

			<remote>: The name of the remote repository (usually origin by default).
			<branch>: The name of the branch you want to pull from (usually main or master).

		Example
			git pull origin main


				Fetch: Downloads the latest changes from the main branch of the origin remote.
				
				Merge: Combines those changes with your current branch.

		1. Understanding the Process

			=> If there are no conflicts between your local changes and the remote changes, the merge will happen automatically.

		2.Handling Merge Conflicts

			=> Sometimes, you may have conflicts between your local changes and the changes in the remote repository. When this happens, Git will prompt you to resolve the conflicts manually.
			=>Example

				if there is a conflict in a file, Git will modify the file to show both your local changes and the changes from the remote:


				<<<<<<< HEAD
				Your local changes
				=======
				Changes from the remote repository
				>>>>>>> branch-name

				You need to manually edit the file to resolve the conflict, and then use the following commands to continue:

					git add <conflicted-file>
					git commit -m "Resolved merge conflict"

		3. Checking the Remote Repository
			To see which remote repository is connected to your local repository, you can use:

				C:\wamp64\www\selfLearn_tut>git remote -v
					origin  https://github.com/vipsthedev/selfLearn_tut.git (fetch)
					origin  https://github.com/vipsthedev/selfLearn_tut.git (push)

		4. Using git pull --rebase (Optional)

			The git pull --rebase command is an alternative to the standard git pull command that, instead of performing a merge, performs a rebase. This can help maintain a cleaner, linear Git history by avoiding "merge commits" that can clutter the history with unnecessary branches

				1.Fetch the changes from the remote repository (this part is the same as a normal git pull).
				2.Rebase your local changes on top of the fetched changes, instead of merging them. This effectively reapplies your local changes as if they were made after the fetched commits, keeping a cleaner commit history.


			Rebase vs Merge

				Merge: Combines the remote changes with your local branch and creates a "merge commit" that shows both histories converging.

				Rebase: Instead of merging, it takes your local changes and applies them on top of the remote changes, making it look like your changes were made after the fetched changes. This prevents extra "merge commits."

			Benefits of Using git pull --rebase
				
				Cleaner Commit History:

					By avoiding merge commits, you get a cleaner, more linear history that is easier to understand and review.

				Better for Shared Repositories:

					If you're working on a project with multiple contributors, a rebased history often looks simpler and more chronological.

				Avoids Duplicate Merge Commits:

					Merge commits can clutter the history, especially if you frequently pull changes from the remote. Using --rebase eliminates this.


			Handling Conflicts in git pull --rebase

				Just like with a normal merge, conflicts can occur when using git pull --rebase. The difference is in how you resolve them:

				If there’s a conflict, Git will pause the rebase and give you a chance to resolve the conflicts.

				After resolving the conflict, use the following commands to continue the rebase:

					git add <conflicted-file>
					git rebase --continue

				If you want to abort the rebase and go back to your previous state, you can use:

					git rebase --abort

			Setting git pull --rebase as Default

				git config --global pull.rebase true

6.  Check  file differnet before commit object

	In Git, you can check the differences between your staged changes (the changes that are ready to be committed) and the latest commit or a specific commit object. This is useful when you want to verify exactly what has changed before making a commit.

	1.Check Differences Between Working Directory and Staging Area

		To see the changes that have been made in your working directory but not yet staged (i.e., the files you have edited but haven't run git add on yet):

			git diff

	2.  Check Differences Between Staged Changes and the Last Commit

		To check the differences between the staged files (the files you have added with git add) and the latest commit (HEAD), you can use the following command:


			git diff --staged

			git add myfile.txt
			git diff --staged

	3. Check Differences Between the Working Directory and a Specific Commit

		If you want to compare your working directory (modified files) with a specific commit (for example, the last commit or a commit with a specific hash), you can use:

			git diff <commit-hash>

			git diff 36e6875dd0a7a9bbb511710e14dae45a57b8e73e

	4. Check Differences Between Two Specific Commits

		git diff <commit-hash-1> <commit-hash-2>
		git diff 36e6875dd0a7a9bbb511710e14dae45a57b8e73e 7306f1a7d1002d80858be8b9921debafd79719de

	5. Check Differences for a Specific File Before Committing

		If you want to check the differences for a specific file before committing, you can run:

			git diff <file-path>

			git diff myfile.txt

	6. Using git status to Check Differences

		Although git status does not show the actual diff, it is useful to check which files have been modified, staged, or are ready to be committed:


			git status


		This shows a summary of:

			Modified files (but not yet staged).
			Staged files (ready to be committed).
			Untracked files.


		1.Check what has changed but not yet staged:
			git diff
		2.Stage the file:
			git add myfile.txt
		3.Check the differences between the staged file and the last commit:
			git diff --staged
		4. If everything looks good, commit:
			git commit -m "Update myfile.txt"

	7. View Full History and Diffs Using git log with Diffs

		You can also view previous commits with the diffs included to understand how files have changed over time:

			git log -p

--------------------------------------
7.  Commit files to GIT respository
	
	=> To commit files to a Git repository, you can use different commands and options based on your workflow.
	   Here’s a breakdown with examples:

	1. Standard Commit

		Commit all changes to tracked files:

		git add .
		git commit -m "Your commit message"

	2. Adding Only Specific Files

		Commit only specific files instead of all changes:

			git add filename1 filename2
			git commit -m "Commit specific files only"

	3.  Commit with Interactive Mode

		git add -p
		git commit -m "Selective chunk commit"

	4. Amend the Last Commit

		Modify the last commit, adding new changes or adjusting the commit message

		git commit --amend -m "Updated commit message with new changes"

	5.  Skip the Staging Area

		Directly commit changes without staging:

		git commit -a -m "Commit all modified files without staging"

	6.  Commit with Date and Author Override

		Specify a different author or date for the commit:

		git commit --author="Author Name <email@example.com>" --date="YYYY-MM-DD HH:MM:SS" -m "Commit with custom author and date"

	7.  Sign-Off the Commit

		Add a “sign-off” line at the end of the commit message, often used in team collaborations:

		git commit -s -m "Add feature XYZ with sign-off"

		Author: vipul agravat <vipul@indolytics.com>
			
			Date:   Sun Oct 27 00:01:08 2024 +0530
			
			Add feature changes with sign-off

		    Signed-off-by: vipul agravat <vipul@indolytics.com>

	8. Commits Empty (No Changes)

		Create an empty commit to mark a milestone or checkpoint

		git commit --allow-empty -m "Marking milestone without file changes"

	9.  Squash Commits

		Combine multiple commits into one (useful for cleanup before merging):


		git rebase -i HEAD~N  # Replace N with the number of commits to squash
		# In the interactive editor, mark commits to be squashed with 's

	10.  Commit in Verbose Mode

		Show the commit diff in the command output for verification:

		git commit -v -m "Commit with diff view"

		=== More option


		1. Using Templates for Commit Messages

			Use a predefined template for commit messages to maintain consistency (like a checklist for each commit):
			
			First, create a template file (e.g., .gitmessage.txt):

		2. Set the template for all commits:

			git config --global commit.template C:/wamp64/www/selfLearn_tut/.gitmessage.txt

		3. Reverting Commits

			git revert <commit-hash>	
		
		4. Amending Commit Author Only

			If you want to change the author of the most recent commit (e.g., if you forgot to set up your Git config correctly):

			git commit --amend --author="New Author <newemail@example.com>"

		5. Splitting a Commit

			If you have changes in a single commit that you want to separate into multiple commits:
			git reset -p HEAD^
		6. Using commit -C to Reuse an Old Commit Message
				git commit -C <commit-hash>

		7. Using --fixup and --squash
			
			if you’re working with multiple commits and need to make quick adjustments:

			--fixup: Create a commit intended to fix a previous commit, useful for marking corrections that you can squash later.

			git commit --fixup=<commit-hash>

			--squash: Combines the new commit into an older commit during a rebase

			git commit --squash=<commit-hash>

			After using --fixup or --squash, you can do an interactive rebase (git rebase -i) to consolidate commits.

		8. Using commit -S to Sign Commits with GPG

			git commit -S -m "Signed commit"


			You’ll need to set up GPG keys first and configure Git to use them.

		9. Mark Commit as WIP (Work in Progress)
				When committing incomplete work:

				git commit -m "WIP: Add partial implementation of feature XYZ"

	 	10. Creating Annotated Tags at the Commit
					For version control or to mark specific points in history:

				git tag -a v1.0 -m "Version 1.0 release"
				git push origin v1.0
		11. Use Commit Reflog for Recovery

			If you accidentally lost a commit, you can use Git’s reflog to recover:


			git reflog
			git checkout <commit-hash>


			This allows you to view and recover from detached HEADs or lost commits by checking out the commit hash from the reflog.
		12. Skip the Pre-Commit Hook

			Sometimes, you may need to bypass pre-commit hooks (e.g., linting checks or tests) temporarily:

			git commit --no-verify -m "Commit message bypassing pre-commit hook"

		13. Create a Commit with Only Metadata Changes
			Sometimes you want to record that you've modified a file without actually changing its content:

				git commit --allow-empty --allow-empty-message -m ""

		14.Force Push a Specific Commit to the Repository

			In case you only want to push a specific commit without affecting others (be careful with force pushing):

			git push origin <commit-hash>:branch-name --force

		15  Using git reset to Unstage Changes


			When you’ve accidentally staged changes and want to unstage them:

			git reset HEAD filename

			This only unstages the file without discarding the changes, moving it back to the working directory.

8.  Check git status [Untracked files, Changes not staged for commit, Changes to be committed]
	
	The git status command gives a detailed view of your current working directory and staging area.

	1. Untracked Files
		Description: Untracked files are files in your working directory that Git is not currently tracking. They haven’t been staged or committed before.

		Cause: These files appear because you created or moved them into the repository directory, but Git does not yet know to include them in the version control system.

		Status Message: Untracked files: followed by a list of files. These files will not be included in a commit unless explicitly staged.


		Example

			Untracked files:
  			(use "git add <file>..." to include in what will be committed)
        		new_file.txt
        		src/new_script.js

        -> To track these files, add them using git add <file>.
		-> To ignore them, you can add them to your .gitignore file, so they no longer show up in git status.
	 
	 2. Changes Not Staged for Commit

	 		Description: These are modifications to files that Git already tracks but haven’t been staged for the next commit. This includes edits to files that were already part of the repository but haven’t been added to the staging area.

			Cause: You edited a tracked file but haven’t added it to the staging area, so it’s recognized by Git but not yet ready to commit.

			Example

			Changes not staged for commit:
			  (use "git add <file>..." to update what will be committed)
			  (use "git restore <file>..." to discard changes in working directory)
			        modified:   existing_file.txt
			        modified:   src/updated_script.js

			  -> Stage the Changes: Use git add <file> to move the changes to the staging area for the next commit.
			  -> Discard the Changes: Use git restore <file> if you want to discard changes in a file and revert it to the last committed state.

	3.Changes to Be Committed

			Description: These are changes that have been added to the staging area (also known as the index). They are ready to be committed to the repository.

			Cause: You added modified files to the staging area, making them ready to be part of the next commit. Files in this section won’t change unless you modify, stage, or unstage them.

			Example

				
				Changes to be committed:
				  (use "git restore --staged <file>..." to unstage)
				        new file:   new_file.txt
				        modified:   existing_file.txt

			-> Commit the Changes: Use git commit -m "Commit message" to finalize these changes and store them in the repository.

			-> Unstage a File: Use git restore --staged <file> to remove a file from the staging area without discarding its changes.

===========================
9.  Undo changes from modified file
	
	To undo changes from a modified file in Git, you have several options depending on your needs. Here’s a breakdown of the methods with examples:

	1. Undo Changes in Working Directory (Unstaged Changes)

		If you’ve modified a file but haven’t staged it yet, you can discard the changes and revert the file to the last committed state.

		git restore <filename>

		Explanation: This resets file.txt to the state of the last commit, removing all uncommitted changes.

		git checkout -- <filename>

		PS C:\wamp64\www\selfLearn_tut> git checkout .\t.txt
		Updated 1 path from the index

		This command is equivalent to git restore but is the older syntax. Both commands revert the file to the last committed state.


	2.Undo Changes in the Staging Area (Staged but Not Committed)

		If you’ve already staged the changes but want to unstage them without discarding the modifications:

		git restore --staged <filename>

		git restore --staged t.txt

		 This moves file.txt back to the working directory, keeping the modifications but removing it from the staging area. The changes are still present in your working directory but will not be included in the next commit unless you stage them again

	3. Undo All Changes Since the Last Commit	

		If you want to discard all changes (both staged and unstaged) for a specific file or all files since the last commit:

		git restore --source=HEAD --staged --worktree <filename>

		git restore --source=HEAD --staged --worktree t.txt
		
		All
		git restore --source=HEAD --staged --worktree .

	4. Undo the Last Commit (Keeping Changes)

		If you have committed the changes but want to undo the commit and keep the changes as staged:

		git reset --soft HEAD~1

		Explanation: This undoes the last commit but keeps your changes staged, so you can edit or modify the commit as needed


	5. Undo the Last Commit (Discarding Changes)

		If you have committed changes but want to discard the last commit entirely:

		git reset --hard HEAD~1

		Explanation: This permanently removes the last commit and all changes, reverting the repository to the state before the last commit. Use this with caution, as it discards changes entirely.


10. Reset modified files

	In Git, you can reset modified files back to their previous state using several different commands depending on the current state of the files (e.g., staged or unstaged). Here’s a guide on how to reset modified files with examples:

	1. Reset Unstaged Changes (Changes in Working Directory)

		If you’ve modified a file but haven’t staged it, you can reset it to the last committed state
		git restore <filename>
		git restore t.txt

	2. Reset Staged Changes (Changes in Staging Area)

		If you have already added changes to the staging area but want to unstage them without discarding the changes, you can move them back to the working directory.

		git restore --staged <filename>

	3. Reset All Changes (Staged and Unstaged) to Last Commit

		If you want to completely discard all changes in both the staging area and the working directory and revert files to the last committed state, you can do so for a specific file or all files.

		git restore --source=HEAD --staged --worktree <filename>
	4. Reset Changes Using git reset (Alternative)

		If you prefer to use git reset, you can reset the state of the files based on their current stage.

		git reset <filename>
		git reset t.txt

		This command will unstage myfile.txt, keeping modifications in the working directory.

	5. Reset Hard and Soft

		If you have committed the changes but want to undo the commit and keep the changes as staged:

		git reset --soft 

		Command for Hard Reset (Discard All Changes):

		git reset --hard


11. Reset commited objects before push [hard reset]
	
	A hard reset in Git allows you to undo committed changes before they are pushed to a remote repository
	This operation rewrites your commit history, making it useful for removing unwanted commits before they become part of the permanent remote history. 

	What Does a Hard Reset Do?
		When you perform a hard reset, Git:
		1.Moves the HEAD pointer back to a specific commit.
		2.Updates the staging area to match this commit.
		3.Discards any changes in the working directory that occurred after the reset point.

	This means any commits after the specified reset point are completely removed from your local history, and their changes are erased from your working directory.

	Example

		three commit 

		A - B - C (HEAD)

		To remove commits B and C, you would perform a hard reset to A.

	Steps for a Hard Reset

		1.Identify the Commit to Reset To

			Use git log to view the commit history and identify the commit hash of the commit you want to keep.

			git log --oneline
		2.Perform the Hard Reset
			Reset the repository to the desired commit (e.g., commit A).

			git reset --hard a8d3f7a

		3. Verify the Reset
			
			Use git log to check your commit history and confirm that only commit A remains.
			git log --oneline

		4. Push the Changes to Remote (if needed)

			if you have previously pushed commits B and C to a remote repository and want to overwrite the remote history to match your local reset, you will need to force push:

				git push origin main --force


		 If you want to keep changes from the removed commits in your working directory, consider using git reset --soft (keeps changes staged) or git reset --mixed (keeps changes unstaged) instead of --hard.
		 By using git reset --hard, you can effectively clean up your commit history and prepare it for a clean push to the remote repository, as if the removed commits never happened.


12. Push commited files to GIT repository

		To push committed files to a Git repository, follow these steps:

		1. Commit Your Changes Locally
			First, ensure that your changes are committed to your local repository.

			git add .
			git commit -m "Your commit message"

		2. Push Changes to Remote Repository
			
			To push your commits to a remote repository, use the git push command. Here’s how:

			git push <remote-name> <branch-name>

			git push origin main


				origin is the default name for the remote repository. You can see it by running git remote -v.

				main is the branch you’re pushing to. Replace main with your branch name if you’re working on a different one.

		3. Pushing to a New Branch

			If you’re pushing to a new branch that doesn’t exist on the remote yet, add the -u option to set up a tracking connection between the local and remote branches:

			git push -u origin git-info-branch

			The -u flag sets origin/new-branch as the default upstream branch, so in future pushes, you can simply use git push

			Push in all branch 

				git push --all origin

			Force Push (Use Caution): If you need to overwrite remote history (e.g., after a reset), use --force:

				git push --force origin main
		4.Push Specific Commits

			To push a single specific commit to the remote, you can use its commit hash:
			git push <remote-name> <commit-hash>:<branch-name

			git push origin abc1234:main


			This pushes only the specified commit to the main branch of the origin remote. Useful in specific scenarios where you only want to share one commit.

		5. Push to Multiple Remotes

			If your repository has multiple remotes, you can push to all remotes with a single command:

			git push --all


			git push origin --all
			git push upstream --all

			 This pushes all branches to the specified remote(s). It’s especially useful for keeping multiple remote repositories in sync.


		4.Push Tags

			Tags are not automatically pushed with branches. To push all tags to the remote repository:
			 
			 git push --tags

			Explanation: Tags are often used to mark release versions. This command ensures all local tags are pushed to the remote.

		5. Force Push (Override Remote History)


			Use with caution, as it can overwrite remote history, affecting collaborators. This is often used after a rebase or a reset.


				git push --force <remote-name> <branch-name>
		
		6. Force Push With Lease

			A safer way to force push, as it checks for changes on the remote and only pushes if there have been no changes by others.


			git push --force-with-lease <remote-name> <branch-name>

			git push --force-with-lease origin main


			This prevents you from accidentally overwriting changes that others may have pushed to the remote branch.

		7.  Push and Set Upstream (for New Branches)

			When pushing a branch for the first time, -u sets up the upstream link so future pushes and pulls can use the branch’s name without specifying remote or branch names.

			git push -u <remote-name> <branch-name>

			git push -u origin feature-branch

			After running this, you can use git pull and git push without specifying origin feature-branch again.

		8. Delete a Remote Branch

			To delete a branch on the remote, you can push a “delete” command:

			git push <remote-name> --delete <branch-name>

			git push origin --delete old-feature-branch
			
			git push origin --delete v1

			This removes the old-feature-branch from the remote repository, which can be useful for cleaning up unused branches.

		9. Dry-Run Push (Test a Push)

			To preview what would be pushed without actually pushing:

			git push --dry-run

			This shows what would happen if you pushed but makes no actual changes, which can be useful for verifying before pushing.

		10. Push with --mirror (Full Mirror of All Refs)

			Used for mirroring an entire repository, including all refs, branches, tags, and remotes. Usually done for cloning a repo structure:


				git push --mirror <remote-name>

				PS C:\wamp64\www\selfLearn_tut> git push --mirror origin
				Enumerating objects: 5, done.
				Counting objects: 100% (5/5), done.
				Delta compression using up to 4 threads
				Compressing objects: 100% (3/3), done.
				Writing objects: 100% (3/3), 548 bytes | 274.00 KiB/s, done.
				Total 3 (delta 2), reused 0 (delta 0), pack-reused 0 (from 0)
				remote: Resolving deltas: 100% (2/2), completed with 2 local objects.
				To https://github.com/vipsthedev/selfLearn_tut.git
				   6e3ecfe..1af2362  git-info-branch -> git-info-branch
				 * [new reference]   origin/HEAD -> origin/HEAD
				 * [new reference]   origin/git-info-branch -> origin/git-info-branch
				 * [new reference]   origin/main -> origin/main
				 * [new reference]   origin/v1 -> origin/v1

				This pushes all branches, tags, and refs to the remote, making it an exact mirror of the local repo. Useful for repository migrations.
The git log command in Git is highly customizable and allows you to view commit history with various options. Here’s a guide to useful git log options with examples:
			11. Push Refspec (Specific Reference)

				Use refspecs to control what branches or tags are pushed.

				git push <remote-name> <local-branch>:<remote-branch>

				git push origin main:production

				This pushes the main branch locally to the production branch on the remote. This is useful for syncing branches with different names or pushing only specific references.



13. Check GIT logs 
	
	The git log command in Git is highly customizable and allows you to view commit history with various options. Here’s a guide to useful git log options with examples:

	1.Basic Git Log

		View the default commit history with basic information (commit hash, author, date, and message).
		 
		 git log 
	
	2.Limit the Number of Commits

		git log -n <number>

		git log -n 10

		This displays the last 10 commits in the log.

	3. One-Line Format
		
		View each commit on a single line for a more compact view.

		git log --oneline

		git log --oneline -n 1

		 Displays each commit as a single line with a shortened commit hash and message
	
	4. Show Commits for a Specific Author

		Filter commits by a specific author.

			git log --author="Author Name"
			git log --author="vipul agravat"

	5. View Commits that Include a Specific File

		View commit history for changes made to a specific file.
		git log -- <filename>

		git log -- t.txt

	6. Show Changes in Each Commit

		Display the full diff (changes made) for each commit.

		 git log -p

		 This shows the complete diff of each commit, useful for reviewing changes.
	7.Customizing Output Format

		You can customize the format to show specific information for each commit.

			git log --pretty=format:"%h - %an, %ar : %s"


			%h: Abbreviated commit hash
			%an: Author name
			%ar: Relative date
			%s: Commit message

	8. Show Commit Graph

		Display commits along with a visual graph of the branch structure.

		git log --oneline --graph

		Shows commits as a graph, useful for understanding branching and merging.

	9.  Filtering Commits by Date Range
		
		View commits within a specific date range.

			git log --since="YYYY-MM-DD" --until="YYYY-MM-DD"

	10. Search Commit Messages

		Search for commits containing specific keywords in their messages.

		git log --grep="keyword"

		git log --grep="push"

	11. Show Only Merge Commits

		Display only commits that were created by merging branches.


		git log --merges

	12.  Stat Option for Summary of Changes

		Display a summary of changes made in each commit (file additions, deletions).

			git log --stat

			git log --stat --oneline

		Explanation: Shows the number of lines added and deleted per file in each commit.

	13. Log with File Path Limiting (Path Limiting)

		Limit the log output to commits that changed files within a specific directory or file path

		git log -- <path>

		git log -- src/

	14. View Commits with Committer Information


		Show committer (who added the commit to the repository) instead of the author.

		git log --pretty=format:"%h - %cn, %cr : %s"


		Explanation:
				%cn: Committer name
				%cr: Relative date of the commit


	15. Check for Specific Author and Date Together

		Filter commits by a specific author and date range.

		git log --author="Author Name" --since="YYYY-MM-DD" --until="YYYY-MM-DD"
		git log --author="vipul agravat" --since="2024-10-01" --until="2024-12-01"


14. Show particular commited object
	
	To view a specific commit in Git, you can use the commit’s hash and view it in detail. Here are several ways to inspect a particular commit:

	1. Using git show
		
		The git show command displays information about a specific commit, including the commit message, author, date, and the actual changes made in that commit

		 git show 
		 git show <commit-hash>
		 git show 07a2d992ddd4d172b2fa9f6acf12cc07f40611b9

		 This displays detailed information about the commit with hash f7c3d2c, showing the diff (changes made) along with the commit metadata.

	2. Using git log for Commit Metadata

		If you want to see only the metadata (without the diff) of a specific commit, you can filter the log output to focus on the commit.

		git log -1 <commit-hash>
		git log -1 07a2d992ddd4d172b2fa9f6acf12cc07f40611b9

	3.View Only the Commit Message

		If you only need to see the commit message of a specific commit, you can use git log with a custom format to limit the output.

		git log -1 --pretty=format:"%s" <commit-hash>
		git log -1 --pretty=format:"%s" 07a2d992ddd4d172b2fa9f6acf12cc07f40611b9
		git log -1 --pretty=format:"%s %ar %cn %cr %an %h %s" 07a2d992ddd4d172b2fa9f6acf12cc07f40611b9
		git log -1 --pretty=format:"%s %ar %cn %cr %an %h %s"

	4. Show the Changes in a Specific File in a Commit

		If you want to see the changes made to a specific file within a particular commit, specify the file name with git show.

		git show <commit-hash> -- <filename>
		git show 07a2d992ddd4d172b2fa9f6acf12cc07f40611b9 -- t.txt

	5.View a Commit in a Compact Format
		You can use git diff-tree for a compact summary of changes in a specific commit.

		git diff-tree --no-commit-id --name-only -r <commit-hash>

		git diff-tree --no-commit-id --name-only -r 07a2d992ddd4d172b2fa9f6acf12cc07f40611b9

		This shows only the file names changed in the specified commit, without the actual diffs.

	6. View Commit with Context Lines

		Show a commit’s changes with a specified number of context lines for each change (e.g., 5 lines).

		git show -U<number> <commit-hash>

		git show -U5  07a2d992ddd4d172b2fa9f6acf12cc07f40611b9

		Displays the diff for the specified commit with 5 lines of context above and below each change.

15. Stash the changes and how to apply changes back from stash
	
	In Git, git stash allows you to temporarily save changes you’ve made to your working directory without committing them, so you can work on something else. Later, you can retrieve (apply) those changes when you’re ready.

	1. Stash Changes
		
		Save your current changes to the stash, clearing the working directory.

		git stash

		PS C:\wamp64\www\selfLearn_tut> git stash
		Saved working directory and index state WIP on git-info-branch: 030ccfe stash details
		
		This stashes both staged and unstaged changes, leaving you with a clean working directory.

	2. View Stashed Changes
		To see a list of all stashes saved, use:

		git stash list

		PS C:\wamp64\www\selfLearn_tut> git stash list
		stash@{0}: WIP on git-info-branch: 030ccfe stash details
		Lists all stashes, each identified with an index (e.g., stash@{0}, stash@{1}, etc.).

	3. Apply the Latest Stash

		To reapply the most recent stash to your working directory without removing it from the stash list:


		git stash apply

 	4. Apply a Specific Stash
 		if you have multiple stashes, you can apply a specific stash by referring to its index.

 		git stash apply stash@{n}
 		git stash apply stash@{1}
 	5. Apply and Remove the Latest Stash (git stash pop)

 		If you want to apply the latest stash and also remove it from the stash list, use git stash pop.

 		git stash pop

 	6. Apply and Remove a Specific Stash

 		git stash pop stash@{n}

 		git stash pop stash@{0}


 	7. Stash Only Unstaged Changes

 		If you only want to stash unstaged changes and leave staged changes intact, use the --keep-index option.

 		git stash push --keep-index

		This stashes only the unstaged changes, keeping the staged changes in the staging area.

16. GIT multiple branches [dev, master, 6.0, 6.0.1, 6.0.2]
17. Create local GIT branch
18. Push local GIT branch and make it remote branch
19. Move between GIT branches
20. Cherry-pick objects from one branch to another branch
21. Continue cherry-pick and abort cherry-pick process
22. Merge changes from one branch to another branch
23. Rebase from one branch to another branch
24. Clone GIT repository with specific branch
25. git Ignore

		=> To ignore files or directories in Git, you need to use a special file called .gitignore. This file tells Git which files or patterns to ignore, meaning they won’t be tracked or shown in git status. Here’s a step-by-step guide:

			1.Create or Open the .gitignore File

				In your repository’s root directory, create a .gitignore file if it doesn’t exist
			
			2.Add Files or Directories to .gitignore

				- Add specific file names or patterns to .gitignore. Here are some common use cases:
				
					Example

					# Ignore a specific file
					secrets.txt

				- Ignore Files by Extension

					*.log
				- Ignore Specific Directory

					/node_modules/
					/public

				- Ignore All Files in a Folder Except One

					config/*
					!config/app.test.js
				
				- Ignore Files in Nested Directories

				 **/.env

			3.Save the .gitignore File

				Once you’ve added the patterns, save the .gitignore file.
			4. Ensure Ignored Files Are Not Tracked by Git
				
				If the file you want to ignore is already tracked by Git (already in the repository), you need to untrack it first. Use:

				git rm --cached <filename>

			5.  Commit Your .gitignore File

				After updating your .gitignore, you can commit the changes

				git add .gitignore
				git commit -m "Add .gitignore file"

			6. Verify Ignored Files Are Not Listed

				Run git status to ensure ignored files are no longer appearing in the list of untracked or tracked files.

1. https://www.sitepoint.com/git-for-beginners/
2. https://www.freecodecamp.org/news/learn-the-basics-of-git-in-under-10-minutes-da548267cc91/
3. https://www.atlassian.com/git/tutorials/atlassian-git-cheatsheet
4.http://internal-docs.fads6.fiareads.com/index.php?id=91

youtube
	https://youtu.be/6El8Ia4fYDc?si=3hi-9eLFqPk-6woJ
	https://youtu.be/cFViH1UnU6M?si=IY0yA4FBRpCbFdPg
	https://youtu.be/QKVarScQigI?si=N8MXVbQbbDN_-thd




Summary

1/2	git init: Initializes a new Git repository in your local directory.
	git add .: Adds files to the staging area.
	git commit -m "message": Commits the changes to the repository.
	git clone [URL]: Clones an existing repository from a remote server to your local machine.
	git push origin main: Pushes local commits to the remote repository.


	----
3
	Use git config --global user.name "Your Name" and git config --global user.email "youremail@example.com" to set your global Git name and email.
	Use git config --global --list to verify the configuration.
	For repository-specific settings, use git config user.name "Repo Name" and git config user.email "repo@example.com".
	
	-----
4 Summary of Common git add Options
git add .: Adds all changes in the current directory and its subdirectories.
git add -A or git add --all: Adds all changes in the entire repository.
git add filename: Adds a specific file to the staging area.
git add file1 file2 ...: Adds multiple specific files.
git add path/to/directory/: Adds all files in a specific directory.
git add *.extension: Adds all files of a specific extension.
git add -p: Interactive mode for adding changes selectively.
git add -f filename: Forces adding a file that is ignored by .gitignore.


5.	
Summary of git pull

	The git pull command fetches and integrates changes from the remote repository into your local repository.
	Example: git pull origin main pulls changes from the main branch of the origin remote.
	You may encounter merge conflicts that need to be manually resolved if your local changes conflict with the remote changes.
	
	You can use git pull --rebase to keep a linear history when pulling changes.
		
		 --rebase:
			What it does: Fetches changes from the remote and rebases your local changes on top of the remote commits.
			Benefits: Produces a cleaner, linear history without merge commits.
			Conflicts: If conflicts arise, resolve them using git add and git rebase --continue.
			Set as default: You can configure Git to always rebase when pulling with git config --global pull.rebase true.

6.
Summary of Commands Diff:

	git diff: Shows differences between the working directory and the staging area.
	git diff --staged: Shows differences between the staged changes and the last commit.
	git diff <commit-hash>: Shows differences between the current state and a specific commit.
	git diff <commit-hash-1> <commit-hash-2>: Shows differences between two specific commits.
	git status: Shows the current status of the working directory, including modified, staged, and untracked files.

7. Summary of commands 

	git add -A	Stage all changes including untracked files
	git commit --amend --author="Name <Email>"	Amend author of the most recent commit
	git revert <commit-hash>	Create a new commit to undo changes of a specific commit
	git commit --fixup=<commit-hash>	Create a fixup commit to be squashed later
	git commit -S -m "Signed commit"	Create a GPG-signed commit
	git commit -p	Commit only specific parts of files
	git commit --no-verify -m "Commit message"	Commit without running pre-commit hooks
	git reflog	View commit history, including detached and rebased commits
	git push origin <commit-hash>:branch-name --force	Push a specific commit forcefully to a branch (use with caution)


8 .Summary of status Commands

Untracked Files :	git add <file>	Track the untracked files
	Add files to .gitignore	Ignore the files permanently

Changes Not Staged for Commit :	git add <file>	Stage changes to the staging area

git restore <file>	Discard local changes and revert to last commit
	Changes to Be Committed	git commit -m "Commit message"	Commit staged changes

git restore --staged <file>	Unstage without discarding change

	Each of these statuses provides visibility into which files are ready to commit, which ones still need staging, and which are entirely new to the repository, allowing you to manage your codebase systematically.

9. Undo changes from modified file
	
	1.Discard unstaged changes in a file	
			git restore <filename>	

		Resets file to last commit, removing unstaged changes
	
	2.Unstage a staged file (keep changes in working dir)

		git restore --staged <filename>

		Unstages file but retains changes in working directory
	
	3.Discard all changes since last commit (single file)

		git restore --source=HEAD --staged --worktree <filename>

		Completely discards changes, resetting file to last commit
	
	4.Undo last commit but keep changes

		git reset --soft HEAD~1
		Undoes commit, keeps changes staged

	5.Undo last commit and discard changes

		git reset --hard HEAD~1

		Removes last commit and discards all changes

10. Reset Summary of Commands

	1.Discard unstaged changes in a file
		git restore <filename>
		Resets file to last commit, removing unstaged changes

	2.Unstage a staged file (keep changes in working directory)
		git restore --staged <filename>
		Unstages file but retains changes in working directory

	3.Discard all changes since last commit (single file)
		git restore --source=HEAD --staged --worktree <filename>
		Resets file to last commit, discarding all changes

	4.Reset all files to last commit

		git restore --source=HEAD --staged --worktree .
		Discards all changes in all files, resetting them to the last commit

	5. Hard reset entire repository to last commit

		git reset --hard

		Resets working directory and staging area to the last commit, discarding all uncommitted changes

12. Summary of Important Push Commands

	git push --tags

		Push all tags to the remote repository

	git push --all

		Push all branches to the specified remote

	git push --force

		Force push, overwriting remote history

	git push --force-with-lease

		Safer force push that checks for remote changes before pushing

	git push -u <remote> <branch>

		Push new branch and set upstream link

	git push <remote> --delete <branch>

		Delete a branch on the remote

	git push --dry-run

		Preview changes before pushing

	git push --mirror <remote>

		Full mirror of the repository, including all refs and branches

	git push <remote> <local-branch>:<remote-branch>

		Push a branch to a different branch name on the remote

13.Summary of Git Log Options

	1.git log -n <number>
		Show only the last specified number of commits
	2.git log --oneline
		Display commits in one-line format
	3.git log --author="<Author Name>"
		Filter commits by a specific author
	4.git log -- <filename>
		Show history of a specific file
	5.git log -p
		how full changes (diffs) for each commit
	6.git log --pretty=format:"..."
		Customize output format for commits
			%h: Abbreviated commit hash
			%an: Author name
			%ar: Relative date
			%s: Commit message
	7.git log --oneline --graph
		Display commit graph in one-line format
	8.git log --since="YYYY-MM-DD" --until="YYYY-MM-DD"
		Filter commits by date range
	9.git log --grep="keyword"
		Search for commits with specific keywords in messages
	10.git log --merges
		Show only merge commits
	11.git log --stat
		Show summary of changes made in each commit
	12.git log -- <path>
		git log -- <path>
	13.git log --author="..." --since="..."

		Filter commits by both author and date range

14.  Summary of Show particular commited object

	 1.git show <commit-hash>

	  	Show full details and diff of the specified commit

	 2.git log -1 <commit-hash>

	 	Display only the metadata of a specific commit

	 3.git log -1 --pretty=format:"%s" <commit-hash>

	 	Show only the commit message of the specified commit

	 4. git show <commit-hash> -- <filename>

	 	Show changes made to a specific file in a commit

	 5.git diff-tree --no-commit-id --name-only -r <commit-hash>

	 	Show only filenames changed in a commit

	 6. git show -U<number> <commit-hash>

	 	Show commit diff with specified number of context lines


25. Summary git ignore 


	1. Create/Open .gitignore: In the root directory of your repository, create a .gitignore file if it doesn't 	exist using:
	2.Add Patterns to Ignore: Open .gitignore in a text editor and add patterns:

		Ignore specific files: secrets.txt
		Ignore all files with an extension: *.log
		Ignore a directory: /node_modules/
		Ignore files except one: config/* then !config/app.config.js
	
	3.Remove Already Tracked Files: If a file is already tracked, untrack it with:

		git rm --cached <filename>
	4.Commit .gitignore: Add and commit the .gitignore file to the repository:

		git add .gitignore
		git commit -m "Add .gitignore file"

	5.Verify: Run git status to ensure ignored files don’t appear.

		The .gitignore helps keep your repository clean by excluding unnecessary or sensitive files.

	===
	git add -A	Stage all changes including untracked files
	git commit --amend --author="Name <Email>"	Amend author of the most recent commit
	git revert <commit-hash>	Create a new commit to undo changes of a specific commit
	git commit --fixup=<commit-hash>	Create a fixup commit to be squashed later
	git commit -S -m "Signed commit"	Create a GPG-signed commit
	git commit -p	Commit only specific parts of files
	git commit --no-verify -m "Commit message"	Commit without running pre-commit hooks
	git reflog	View commit history, including detached and rebased commits
	git push origin <commit-hash>:branch-name --force	Push a specific commit forcefully to a branch (use with caution)



==================================

https://chatgpt.com/c/671c9c06-7844-800b-9766-ff0d0198bcd3